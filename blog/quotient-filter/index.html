<!doctype html><html lang=jp><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>Quotient Filter を実装する</title><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><style>body{--primary-color:#5871a2;--primary-pale-color:#5871a210;--text-color:#3c4043;--text-pale-color:#a3a5a9;--bg-color:#fff;--highlight-mark-color:#5f75b035;--blockquote-color:#8e8d91;--callout-note-color:#5871a2;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460}body.dark{--primary-color:#5d77ac;--primary-pale-color:#5d77ac20;--text-color:#9197a5;--text-pale-color:#656a74;--bg-color:#18191b;--highlight-mark-color:#5f75b035;--blockquote-color:#747983;--callout-note-color:#5d77ac;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460}body{--main-font:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:768px;--main-max-width:768px;--avatar-size:56px;--homepage-font-size:16px;--homepage-line-height:1.75;--paragraph-font-size:16px;--paragraph-line-height:1.75;--aside-font-size:15px;--img-border-radius:0px;--detail-border-radius:0px;--dark-mode-img-brightness:.75;--dark-mode-chart-brightness:.75;--inline-code-border-radius:2px;--inline-code-bg-color:var(--primary-pale-color);--block-code-border-radius:0px;--block-code-border-color:var(--primary-color);--detail-border-color:var(--primary-color)}</style><link href=/main.css rel=stylesheet><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css integrity=sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+ rel=stylesheet><script crossorigin defer integrity=sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg src=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js></script><script crossorigin defer integrity=sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk src=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js></script><script crossorigin defer integrity=sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi src=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            throwOnError: false
        });
    });</script><meta content="Quotient Filter を実装する" property=og:title><meta content=article property=og:type><meta content=https://donkomura.github.io/blog/quotient-filter/ property=og:url><meta content=https://donkomura.github.io/assets/cover.png property=og:image><meta content=summary_large_image name=twitter:card><meta content="Quotient Filter を実装する" name=twitter:title><meta content=https://donkomura.github.io/assets/cover.png name=twitter:image><script src="https://www.googletagmanager.com/gtag/js?id=G-2PCJBTEWV0" async></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2PCJBTEWV0');</script><body class=post><script>const theme = sessionStorage.getItem('theme');
    const match = window.matchMedia("(prefers-color-scheme: dark)").matches
    if ((theme && theme == 'dark') || (!theme && match)) {
      document.body.classList.add('dark');
      const hl = document.querySelector('link#hl');
      if (hl) hl.href = '/hl-dark.css';
    }</script><header><div id=header-wrapper><nav><a class=instant href=/>donko</a><button aria-label="toggle expand" class=separator id=toggler>::</button><span class="wrap left fold">{</span><a class=instant href=/blog>blog</a><span class="wrap-separator fold">,</span><a class="instant fold" href=/about>about</a><span class="wrap right fold">} ;</span></nav><div id=btns><a aria-label="rss feed" href=/blog/feed.xml id=rss-btn><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M3 17C5.20914 17 7 18.7909 7 21H3V17ZM3 10C9.07513 10 14 14.9249 14 21H12C12 16.0294 7.97056 12 3 12V10ZM3 3C12.9411 3 21 11.0589 21 21H19C19 12.1634 11.8366 5 3 5V3Z" fill=currentColor></path></svg></a><button aria-label="theme switch" id=theme-toggle><span class=moon-icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></span> <span class=sun-icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill=currentColor></path></svg></span></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><dialog id=rss-mask><div><a href=https://donkomura.github.io/blog/feed.xml>https://donkomura.github.io/blog/feed.xml</a><button data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' aria-label=copy autofocus data-link=https://donkomura.github.io/blog/feed.xml><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill=currentColor></path></svg></button></div></dialog><div id=wrapper><div id=blank></div><aside><nav><ul><li><a class=h2 href=#quotient-filter-toha>Quotient Filter とは</a> <ul><li><a class=h3 href=#bloom-filter-tonowei-i>Bloom Filter との違い</a></ul><li><a class=h2 href=#ji-ben-de-nashi-zu-mi>基本的な仕組み</a> <ul><li><a class=h3 href=#hatusiyuzhi-nofen-ge>ハッシュ値の分割</a><li><a class=h3 href=#run-tokurasutaringu>Run とクラスタリング</a><li><a class=h3 href=#metadeta>メタデータ</a></ul><li><a class=h2 href=#shi-zhuang-nogai-yao>実装の概要</a> <ul><li><a class=h3 href=#zhu-yao-nacao-zuo>主要な操作</a></ul><li><a class=h2 href=#shi-zhuang-noxiang-xi>実装の詳細</a> <ul><li><a class=h3 href=#surotutogou-zao-tobitutocao-zuo>スロット構造とビット操作</a><li><a class=h3 href=#cha-ru-chu-li-noxiang-xi>挿入処理の詳細</a><li><a class=h3 href=#jian-suo-chu-li-noxiang-xi>検索処理の詳細</a></ul><li><a class=h2 href=#matome>まとめ</a></ul></nav><button aria-label="back to top" id=back-to-top><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill=currentColor></path></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1>Quotient Filter を実装する</h1><div id=post-info><div id=date><span id=publish>2025-10-25</span></div><div id=tags><a class=instant href=https://donkomura.github.io/tags/rust><span>#</span>rust</a><a class=instant href=https://donkomura.github.io/tags/algorithm><span>#</span>algorithm</a><a class=instant href=https://donkomura.github.io/tags/data-structure><span>#</span>data-structure</a><a class=instant href=https://donkomura.github.io/tags/hash><span>#</span>hash</a></div></div><p>『大規模データセットのためのアルゴリズムとデータ構造』という本を読んでいる。 第一部では確率的な手法を使った簡潔なデータ構造について紹介されている。 Quotient Filter はそのようなデータ構造のひとつであり、 Bloom Filter と同様の機能を提供している一方で全く異なる設計となっている。 仕組みをより深く理解するべく、この Quotient Filter を実装してみる。 コードは <a rel="nofollow noreferrer" href=https://github.com/donkomura/hash_bench/blob/2464dbfb9336c3d583a2a73d92506016d315eaf2/src/quotient_filter.rs>GitHub リポジトリ</a> で公開している。<h1 id=quotient-filter-toha>Quotient Filter とは<a aria-label="Anchor link for: quotient-filter-toha" class=zola-anchor href=#quotient-filter-toha style=visibility:hidden></a></h1><p>Quotient Filter (QF) は 2012 年に Bender らによって提案された確率的データ構造<sup class=footnote-reference><a href=#1>1</a></sup>で、集合のメンバーシップテストを効率的に行うことができる（<a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Approximate_membership_query_filter>Approximate membership query filter; AMQ filter</a> のひとつ）。 「要素が集合に含まれているか」を高速に判定できるが、偽陽性（False Positive）が発生する可能性がある。 つまり、実際には存在しない要素を「存在する」と誤って判定することがある。<h2 id=bloom-filter-tonowei-i>Bloom Filter との違い<a aria-label="Anchor link for: bloom-filter-tonowei-i" class=zola-anchor href=#bloom-filter-tonowei-i style=visibility:hidden></a></h2><p>既存の手法として本にも登場した Bloom Filter (BF) との違いが言及されていたので整理する。<ul><li>アクセス局所性 <ul><li>BF ではデータの書き込みはランダムアクセスとなるが、 QF ではデータアクセスが局所化している</ul><li>機能 <ul><li>BF では削除できないが、 QF では削除・動的リサイズ・マージをサポートしている</ul><li>性能 <ul><li>局所化されたアクセスが可能なため、挿入やRAMの容量を越える規模での操作が BF よりも良い性能となる<li>特にストレージにデータがある場合では連続アクセスとなる QF の方が有利</ul></ul><p>BF では複数のハッシュ関数でスロットを埋める必要があるが、 QF ではハッシュ値をもとに線形探索でスロットを埋める。 基本的にはこの設計の違いが性能に影響を与えている。 なお後述するが、 QF の方が線形探索のために使うメタデータを保持する必要があるため BF よりも多くのメモリを使用する。<h1 id=ji-ben-de-nashi-zu-mi>基本的な仕組み<a aria-label="Anchor link for: ji-ben-de-nashi-zu-mi" class=zola-anchor href=#ji-ben-de-nashi-zu-mi style=visibility:hidden></a></h1><h2 id=hatusiyuzhi-nofen-ge>ハッシュ値の分割<a aria-label="Anchor link for: hatusiyuzhi-nofen-ge" class=zola-anchor href=#hatusiyuzhi-nofen-ge style=visibility:hidden></a></h2><p>ハッシュ値を <strong>Quotient</strong>（商）と <strong>Remainder</strong>（余り）に分割し、 Quotient を元に線形探索を施してスロットに Remainder 入れていく。 ハッシュ値を <code>h</code> ビットとすると、上位 <code>q</code> ビットを Quotient、下位 <code>r</code> ビットを Remainder として扱う（<code>h = q + r</code>）。<pre style=color:#f8f8f2;background-color:#272822><code><span>hash(key) = [quotient (q bits)][remainder (r bits)]
</span></code></pre><ul><li><strong>Quotient</strong>: フィルタのどのスロットに格納するかを決定するインデックス（<code>2^q</code> 個のスロット）<li><strong>Remainder</strong>: スロットに格納される実際の値</ul><p>例えば、<code>q=8</code>, <code>r=4</code> の場合、ハッシュ値 <code>0b111111110000</code> は以下のように分割される：<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span>quotient  </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0b11111111  </span><span style=color:#75715e>// 255
</span><span>remainder </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0b0000      </span><span style=color:#75715e>// 0
</span></code></pre><h2 id=run-tokurasutaringu>Run とクラスタリング<a aria-label="Anchor link for: run-tokurasutaringu" class=zola-anchor href=#run-tokurasutaringu style=visibility:hidden></a></h2><p>探索をする際には Quotient が主に使われる。 Quotient が同じものや隣接する Quotient を線形探索して目的のハッシュ値を検索する。 同じ Quotient のスロット列とこれらを合わせた列について呼称があるので実装を説明する前に紹介する。<h3 id=run>Run<a aria-label="Anchor link for: run" class=zola-anchor href=#run style=visibility:hidden></a></h3><p>同じ Quotient を持つ要素の集まりを <strong>Run</strong> と呼ぶ。 Run 内では Remainder の昇順で要素が並べられる。<h3 id=cluster>Cluster<a aria-label="Anchor link for: cluster" class=zola-anchor href=#cluster style=visibility:hidden></a></h3><p>複数の Run が連続して配置されている場合、これを <strong>クラスター</strong> と呼ぶ。 クラスターが形成されると、本来の位置（ホームスロット）から離れた位置に要素が配置される（Shifted）。<h2 id=metadeta>メタデータ<a aria-label="Anchor link for: metadeta" class=zola-anchor href=#metadeta style=visibility:hidden></a></h2><p>Remainder の挿入は Quotient を元に実施される。 Quotient が衝突した際には本来挿入されるべき位置からずれて挿入されることがある。 基本的には線形探索で後続のスロットに挿入されるが、スロットがどの Run のものなのか判別がつかなくなる。 そこで以下のフラグを使って探索を支援する。<ol><li><strong>Occupied (is_occupied)</strong>: そのスロットのインデックスを Quotient として持つ要素が存在するか<li><strong>Continued (is_continued)</strong>: そのスロットが Run の一部（先頭以外）であるか<li><strong>Shifted (is_shifted)</strong>: そのスロットに格納された Remainder が本来の位置からシフトされているか</ol><h1 id=shi-zhuang-nogai-yao>実装の概要<a aria-label="Anchor link for: shi-zhuang-nogai-yao" class=zola-anchor href=#shi-zhuang-nogai-yao style=visibility:hidden></a></h1><h2 id=zhu-yao-nacao-zuo>主要な操作<a aria-label="Anchor link for: zhu-yao-nacao-zuo" class=zola-anchor href=#zhu-yao-nacao-zuo style=visibility:hidden></a></h2><p>Quotient Filter は以下の主要な操作をサポートする：<h3 id=cha-ru-insert>挿入（Insert）<a aria-label="Anchor link for: cha-ru-insert" class=zola-anchor href=#cha-ru-insert style=visibility:hidden></a></h3><p>挿入操作は以下の手順で行われる：<ol><li>キーをハッシュし、Quotient と Remainder に分割<li>Quotient に対応するスロットを確認<li>スロットが空なら直接挿入<li>スロットが使用中なら Cluster の先頭から Run の位置を走査・特定し、適切な位置に挿入</ol><p>衝突が発生した場合、Run 内で Remainder の昇順を保つように要素を配置し、必要に応じて後続の要素をシフトする。 昇順に保つことで探索時に Run 全体を検索することなく、見つかった時点で探索を打ち切ることができる。<h3 id=jian-suo-lookup>検索（Lookup）<a aria-label="Anchor link for: jian-suo-lookup" class=zola-anchor href=#jian-suo-lookup style=visibility:hidden></a></h3><p>検索操作は以下の手順で行われる：<ol><li>キーをハッシュし、Quotient と Remainder に分割<li>Quotient に対応するスロットが Occupied か確認<li>Occupied でなければ要素は存在しない<li>Cluster の先頭から Run を走査<li>Run 内を線形探索して Remainder が一致するか確認</ol><h3 id=risaizu-resize>リサイズ（Resize）<a aria-label="Anchor link for: risaizu-resize" class=zola-anchor href=#risaizu-resize style=visibility:hidden></a></h3><p>フィルタの負荷が高くなる、つまりクラスタが大きくなると性能劣化も大きくなる傾向にある<sup class=footnote-reference><a href=#2>2</a></sup>。 色々やり方はあるが、今回は分かり易さを重視してリサイズ・再挿入を行った。 他には本書で言及されているように Remainder のビットを Quotient に寄せることでテーブルを実質倍にすることができる。<h3 id=mazi-merge>マージ（Merge）<a aria-label="Anchor link for: mazi-merge" class=zola-anchor href=#mazi-merge style=visibility:hidden></a></h3><p>複数の QF を結合する操作は、分散システムでの集約などに有用である。 両方のフィルタからすべてのキーを収集し、十分な容量を持つ新しいフィルタに再挿入する。<h1 id=shi-zhuang-noxiang-xi>実装の詳細<a aria-label="Anchor link for: shi-zhuang-noxiang-xi" class=zola-anchor href=#shi-zhuang-noxiang-xi style=visibility:hidden></a></h1><h2 id=surotutogou-zao-tobitutocao-zuo>スロット構造とビット操作<a aria-label="Anchor link for: surotutogou-zao-tobitutocao-zuo" class=zola-anchor href=#surotutogou-zao-tobitutocao-zuo style=visibility:hidden></a></h2><p>各スロットは <code>u64</code> の1ワードで表現され、以下のようにビットを分割している。<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#66d9ef;font-style:italic>const </span><span style=color:#ae81ff>FLAG_BITS</span><span>: </span><span style=color:#66d9ef;font-style:italic>u64 </span><span style=color:#f92672>= </span><span style=color:#ae81ff>3</span><span>;
</span><span style=color:#66d9ef;font-style:italic>const </span><span style=color:#ae81ff>FLAG_MASK</span><span>: </span><span style=color:#66d9ef;font-style:italic>u64 </span><span style=color:#f92672>= </span><span>(</span><span style=color:#ae81ff>1 </span><span style=color:#f92672>&lt;&lt; </span><span style=color:#ae81ff>FLAG_BITS</span><span>) </span><span style=color:#f92672>- </span><span style=color:#ae81ff>1</span><span>;
</span><span style=color:#66d9ef;font-style:italic>const </span><span style=color:#ae81ff>FLAG_OCCUPIED</span><span>: </span><span style=color:#66d9ef;font-style:italic>u64 </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>&lt;&lt; </span><span style=color:#ae81ff>0</span><span>;
</span><span style=color:#66d9ef;font-style:italic>const </span><span style=color:#ae81ff>FLAG_CONTINUED</span><span>: </span><span style=color:#66d9ef;font-style:italic>u64 </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>&lt;&lt; </span><span style=color:#ae81ff>1</span><span>;
</span><span style=color:#66d9ef;font-style:italic>const </span><span style=color:#ae81ff>FLAG_SHIFTED</span><span>: </span><span style=color:#66d9ef;font-style:italic>u64 </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>&lt;&lt; </span><span style=color:#ae81ff>2</span><span>;
</span><span>
</span><span style=color:#66d9ef;font-style:italic>struct </span><span>Slot {
</span><span>    data: </span><span style=color:#66d9ef;font-style:italic>u64</span><span>,
</span><span>}
</span></code></pre><p>下位3ビットがフラグ、残りが Remainder となる。<pre style=color:#f8f8f2;background-color:#272822><code><span>[Remainder (61 bits)][Shifted][Continued][Occupied]
</span></code></pre><p>フラグの取得・設定は以下のように実装される。<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#66d9ef;font-style:italic>impl </span><span>Slot {
</span><span>    </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>remainder</span><span>(</span><span style=color:#f92672>&</span><span style=color:#fd971f;font-style:italic>self</span><span>) -> </span><span style=color:#66d9ef;font-style:italic>u64 </span><span>{
</span><span>        self.data </span><span style=color:#f92672>>> </span><span style=color:#ae81ff>FLAG_BITS
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>set_remainder</span><span>(</span><span style=color:#f92672>&mut </span><span style=color:#fd971f;font-style:italic>self</span><span>, </span><span style=color:#fd971f;font-style:italic>remainder</span><span>: </span><span style=color:#66d9ef;font-style:italic>u64</span><span>) {
</span><span>        </span><span style=color:#66d9ef;font-style:italic>let</span><span> flags </span><span style=color:#f92672>= </span><span>self.data </span><span style=color:#f92672>& </span><span style=color:#ae81ff>FLAG_MASK</span><span>;
</span><span>        self.data </span><span style=color:#f92672>= </span><span>(remainder </span><span style=color:#f92672>&lt;&lt; </span><span style=color:#ae81ff>FLAG_BITS</span><span>) </span><span style=color:#f92672>|</span><span> flags;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>is_occupied</span><span>(</span><span style=color:#f92672>&</span><span style=color:#fd971f;font-style:italic>self</span><span>) -> </span><span style=color:#66d9ef;font-style:italic>bool </span><span>{
</span><span>        (self.data </span><span style=color:#f92672>& </span><span style=color:#ae81ff>FLAG_OCCUPIED</span><span>) </span><span style=color:#f92672>!= </span><span style=color:#ae81ff>0
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>set_occupied</span><span>(</span><span style=color:#f92672>&mut </span><span style=color:#fd971f;font-style:italic>self</span><span>, </span><span style=color:#fd971f;font-style:italic>value</span><span>: </span><span style=color:#66d9ef;font-style:italic>bool</span><span>) {
</span><span>        </span><span style=color:#f92672>if</span><span> value {
</span><span>            self.data </span><span style=color:#f92672>|= </span><span style=color:#ae81ff>FLAG_OCCUPIED</span><span>;
</span><span>        } </span><span style=color:#f92672>else </span><span>{
</span><span>            self.data </span><span style=color:#f92672>&= !</span><span style=color:#ae81ff>FLAG_OCCUPIED</span><span>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h2 id=cha-ru-chu-li-noxiang-xi>挿入処理の詳細<a aria-label="Anchor link for: cha-ru-chu-li-noxiang-xi" class=zola-anchor href=#cha-ru-chu-li-noxiang-xi style=visibility:hidden></a></h2><h3 id=kong-nosurotutohenocha-ru>空のスロットへの挿入<a aria-label="Anchor link for: kong-nosurotutohenocha-ru" class=zola-anchor href=#kong-nosurotutohenocha-ru style=visibility:hidden></a></h3><p>最もシンプルなケースは、Quotient のスロットが空の場合である。<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#f92672>if </span><span>self.filter[q_idx].</span><span style=color:#66d9ef>is_empty</span><span>() {
</span><span>    self.filter[q_idx].</span><span style=color:#66d9ef>set_remainder</span><span>(remainder);
</span><span>    self.filter[q_idx].</span><span style=color:#66d9ef>set_occupied</span><span>(</span><span style=color:#ae81ff>true</span><span>);
</span><span>    self.entries </span><span style=color:#f92672>+= </span><span style=color:#ae81ff>1</span><span>;
</span><span>    </span><span style=color:#f92672>return</span><span>;
</span><span>}
</span></code></pre><h3 id=run-henocha-ru-tosotobao-chi>Run への挿入とソート保持<a aria-label="Anchor link for: run-henocha-ru-tosotobao-chi" class=zola-anchor href=#run-henocha-ru-tosotobao-chi style=visibility:hidden></a></h3><p>同じ Quotient を持つ要素を挿入する場合、Run 内で Remainder の昇順を保つ必要がある。<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#66d9ef;font-style:italic>let</span><span> run_head </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>find_run_head</span><span>(q_idx);
</span><span style=color:#66d9ef;font-style:italic>let </span><span style=color:#f92672>mut</span><span> insert_pos </span><span style=color:#f92672>=</span><span> run_head;
</span><span>
</span><span style=color:#f92672>if !</span><span>self.filter[insert_pos].</span><span style=color:#66d9ef>is_empty</span><span>() </span><span style=color:#f92672>&& </span><span>self.filter[insert_pos].</span><span style=color:#66d9ef>remainder</span><span>() </span><span style=color:#f92672>&lt;</span><span> remainder {
</span><span>    </span><span style=color:#f92672>loop </span><span>{
</span><span>        insert_pos </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>next_index</span><span>(insert_pos);
</span><span>        </span><span style=color:#f92672>if !</span><span>(self.filter[insert_pos].</span><span style=color:#66d9ef>is_continued</span><span>()
</span><span>            </span><span style=color:#f92672>&& </span><span>self.filter[insert_pos].</span><span style=color:#66d9ef>remainder</span><span>() </span><span style=color:#f92672>&lt;</span><span> remainder)
</span><span>        {
</span><span>            </span><span style=color:#f92672>break</span><span>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h3 id=sihutocao-zuo>シフト操作<a aria-label="Anchor link for: sihutocao-zuo" class=zola-anchor href=#sihutocao-zuo style=visibility:hidden></a></h3><p>挿入位置にすでに別の要素がある場合、後続の要素を1つずつシフトして空きスロットを作る。 スロット列は循環バッファとしている。<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#66d9ef;font-style:italic>let </span><span style=color:#f92672>mut</span><span> empty_pos </span><span style=color:#f92672>=</span><span> insert_pos;
</span><span style=color:#f92672>while !</span><span>self.filter[empty_pos].</span><span style=color:#66d9ef>is_empty</span><span>() {
</span><span>    empty_pos </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>next_index</span><span>(empty_pos);
</span><span>}
</span><span>
</span><span style=color:#66d9ef;font-style:italic>let </span><span style=color:#f92672>mut</span><span> curr </span><span style=color:#f92672>=</span><span> empty_pos;
</span><span style=color:#f92672>while</span><span> curr </span><span style=color:#f92672>!=</span><span> insert_pos {
</span><span>    </span><span style=color:#66d9ef;font-style:italic>let</span><span> prev </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>prev_index</span><span>(curr);
</span><span>    curr </span><span style=color:#f92672>=</span><span> prev;
</span><span>}
</span><span>
</span><span>self.filter[insert_pos].</span><span style=color:#66d9ef>set_remainder</span><span>(remainder);
</span><span>self.filter[insert_pos].</span><span style=color:#66d9ef>set_shifted</span><span>(insert_pos </span><span style=color:#f92672>!=</span><span> q_idx);
</span></code></pre><h2 id=jian-suo-chu-li-noxiang-xi>検索処理の詳細<a aria-label="Anchor link for: jian-suo-chu-li-noxiang-xi" class=zola-anchor href=#jian-suo-chu-li-noxiang-xi style=visibility:hidden></a></h2><h3 id=run-head-notan-suo>Run Head の探索<a aria-label="Anchor link for: run-head-notan-suo" class=zola-anchor href=#run-head-notan-suo style=visibility:hidden></a></h3><p>Run のヘッドを見つけるためにはまず所属する Cluster の先頭からみる必要がある。 Cluster の先頭は <code>Shifted</code> となっているスロットを戻ることで簡単に見つかる。 Cluster の先頭が見つかったら、当該 Run の先頭を探索する。<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>find_run_head</span><span>(</span><span style=color:#f92672>&</span><span style=color:#fd971f;font-style:italic>self</span><span>, </span><span style=color:#fd971f;font-style:italic>home_idx</span><span>: </span><span style=color:#66d9ef;font-style:italic>usize</span><span>) -> </span><span style=color:#66d9ef;font-style:italic>usize </span><span>{
</span><span>    </span><span style=color:#66d9ef;font-style:italic>let </span><span style=color:#f92672>mut</span><span> bucket </span><span style=color:#f92672>=</span><span> home_idx;
</span><span>    </span><span style=color:#f92672>while </span><span>self.filter[bucket].</span><span style=color:#66d9ef>is_shifted</span><span>() {
</span><span>        bucket </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>prev_index</span><span>(bucket);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#66d9ef;font-style:italic>let </span><span style=color:#f92672>mut</span><span> run_head </span><span style=color:#f92672>=</span><span> bucket;
</span><span>    </span><span style=color:#66d9ef;font-style:italic>let </span><span style=color:#f92672>mut</span><span> probe </span><span style=color:#f92672>=</span><span> bucket;
</span><span>    </span><span style=color:#f92672>while</span><span> probe </span><span style=color:#f92672>!=</span><span> home_idx {
</span><span>        run_head </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>next_index</span><span>(run_head);
</span><span>        </span><span style=color:#f92672>while </span><span>self.filter[run_head].</span><span style=color:#66d9ef>is_continued</span><span>() {
</span><span>            run_head </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>next_index</span><span>(run_head);
</span><span>        }
</span><span>        probe </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>next_index</span><span>(probe);
</span><span>        </span><span style=color:#f92672>while !</span><span>self.filter[probe].</span><span style=color:#66d9ef>is_occupied</span><span>() {
</span><span>            probe </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>next_index</span><span>(probe);
</span><span>        }
</span><span>    }
</span><span>    run_head
</span><span>}
</span></code></pre><h3 id=run-nei-noxian-xing-tan-suo>Run 内の線形探索<a aria-label="Anchor link for: run-nei-noxian-xing-tan-suo" class=zola-anchor href=#run-nei-noxian-xing-tan-suo style=visibility:hidden></a></h3><p>Run の先頭が見つかったら、Continued フラグを追いながら一致する Remainder を探す。 挿入時に昇順にしているので見つかったら途中で探索を打ち切ってよい。<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#f92672>pub </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>lookup</span><span>(</span><span style=color:#f92672>&</span><span style=color:#fd971f;font-style:italic>self</span><span>, </span><span style=color:#fd971f;font-style:italic>key</span><span>: </span><span style=color:#66d9ef;font-style:italic>u64</span><span>) -> </span><span style=color:#66d9ef;font-style:italic>bool </span><span>{
</span><span>    </span><span style=color:#66d9ef;font-style:italic>let </span><span>(quotient, remainder) </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>split</span><span>(key);
</span><span>    </span><span style=color:#66d9ef;font-style:italic>let</span><span> q_idx </span><span style=color:#f92672>=</span><span> quotient </span><span style=color:#f92672>as </span><span style=color:#66d9ef;font-style:italic>usize</span><span>;
</span><span>
</span><span>    </span><span style=color:#f92672>if !</span><span>self.filter[q_idx].</span><span style=color:#66d9ef>is_occupied</span><span>() {
</span><span>        </span><span style=color:#f92672>return </span><span style=color:#ae81ff>false</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#66d9ef;font-style:italic>let</span><span> run_head </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>find_run_head</span><span>(q_idx);
</span><span>    </span><span style=color:#f92672>if </span><span>self.filter[run_head].</span><span style=color:#66d9ef>remainder</span><span>() </span><span style=color:#f92672>==</span><span> remainder {
</span><span>        </span><span style=color:#f92672>return </span><span style=color:#ae81ff>true</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#66d9ef;font-style:italic>let </span><span style=color:#f92672>mut</span><span> idx </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>next_index</span><span>(run_head);
</span><span>    </span><span style=color:#f92672>while </span><span>self.filter[idx].</span><span style=color:#66d9ef>is_continued</span><span>() {
</span><span>        </span><span style=color:#f92672>if </span><span>self.filter[idx].</span><span style=color:#66d9ef>remainder</span><span>() </span><span style=color:#f92672>==</span><span> remainder {
</span><span>            </span><span style=color:#f92672>return </span><span style=color:#ae81ff>true</span><span>;
</span><span>        }
</span><span>        idx </span><span style=color:#f92672>= </span><span>self.</span><span style=color:#66d9ef>next_index</span><span>(idx);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#ae81ff>false
</span><span>}
</span></code></pre><h1 id=matome>まとめ<a aria-label="Anchor link for: matome" class=zola-anchor href=#matome style=visibility:hidden></a></h1><p>Bloom Filter のような単純な仕組みかと思いきや、連続アクセスにするための工夫として Quotient や Run、メタデータを導入していて結構複雑な印象だった。 内容が分かるとそれほど凝った実装にはならないはず...<p>Quotient Filter についての研究は直近でも行われており、特に <a rel="nofollow noreferrer" href=https://dl.acm.org/doi/10.1145/3035918.3035963>CQF</a> や <a rel="nofollow noreferrer" href=https://ieeexplore.ieee.org/document/8425199>Quotient Filters: Approximate Membership Queries on the GPU</a> あたりが気になるので時間のある時に読んでみようと思う。<hr><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p><a rel="nofollow noreferrer" href=https://vldb.org/pvldb/vol5/p1627_michaelabender_vldb2012.pdf>Don't Thrash: How to Cache Your Hash on Flash</a></div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>本書では充填率が 75~80% になると性能が大きく低下すると説明している</div></article></div><footer><div class=copyright><p>© 2025 donko</div><div class=credits>powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>serene</a></div></footer></main></div><script src=/js/lightense.min.js></script><script src=/js/main.js></script>