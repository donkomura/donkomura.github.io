<!doctype html><html lang=jp><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><meta content="<p>分散システムにおける合意形成アルゴリズムとして知られている Raft を、Rust で実装してみた。この記事では、Rust の型システムとトレイトを活用した設計について紹介する。</p>" name=description><title>RustでRaft Consensus Algorithmを実装した</title><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><style>body{--primary-color:#5871a2;--primary-pale-color:#5871a210;--text-color:#3c4043;--text-pale-color:#a3a5a9;--bg-color:#fff;--highlight-mark-color:#5f75b035;--blockquote-color:#8e8d91;--callout-note-color:#5871a2;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460}body.dark{--primary-color:#5d77ac;--primary-pale-color:#5d77ac20;--text-color:#9197a5;--text-pale-color:#656a74;--bg-color:#18191b;--highlight-mark-color:#5f75b035;--blockquote-color:#747983;--callout-note-color:#5d77ac;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460}body{--main-font:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:768px;--main-max-width:768px;--avatar-size:56px;--homepage-font-size:16px;--homepage-line-height:1.75;--paragraph-font-size:16px;--paragraph-line-height:1.75;--aside-font-size:15px;--img-border-radius:0px;--detail-border-radius:0px;--dark-mode-img-brightness:.75;--dark-mode-chart-brightness:.75;--inline-code-border-radius:2px;--inline-code-bg-color:var(--primary-pale-color);--block-code-border-radius:0px;--block-code-border-color:var(--primary-color);--detail-border-color:var(--primary-color)}</style><link href=/main.css rel=stylesheet><meta content="RustでRaft Consensus Algorithmを実装した" property=og:title><meta content=article property=og:type><meta content=https://donkomura.github.io/blog/raft-implementation-in-rust/ property=og:url><meta content="<p>分散システムにおける合意形成アルゴリズムとして知られている Raft を、Rust で実装してみた。この記事では、Rust の型システムとトレイトを活用した設計について紹介する。</p>" property=og:description><meta content=summary_large_image name=twitter:card><meta content="RustでRaft Consensus Algorithmを実装した" name=twitter:title><meta content="<p>分散システムにおける合意形成アルゴリズムとして知られている Raft を、Rust で実装してみた。この記事では、Rust の型システムとトレイトを活用した設計について紹介する。</p>" name=twitter:description><script src="https://www.googletagmanager.com/gtag/js?id=G-2PCJBTEWV0" async></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2PCJBTEWV0');</script><body class=post><script>const theme = sessionStorage.getItem('theme');
    const match = window.matchMedia("(prefers-color-scheme: dark)").matches
    if ((theme && theme == 'dark') || (!theme && match)) {
      document.body.classList.add('dark');
      const hl = document.querySelector('link#hl');
      if (hl) hl.href = '/hl-dark.css';
    }</script><header><div id=header-wrapper><nav><a class=instant href=/>donko</a><button aria-label="toggle expand" class=separator id=toggler>::</button><span class="wrap left fold">{</span><a class=instant href=/blog>blog</a><span class="wrap-separator fold">,</span><a class="instant fold" href=/about>about</a><span class="wrap right fold">} ;</span></nav><div id=btns><a aria-label="rss feed" href=/blog/feed.xml id=rss-btn><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M3 17C5.20914 17 7 18.7909 7 21H3V17ZM3 10C9.07513 10 14 14.9249 14 21H12C12 16.0294 7.97056 12 3 12V10ZM3 3C12.9411 3 21 11.0589 21 21H19C19 12.1634 11.8366 5 3 5V3Z" fill=currentColor></path></svg></a><button aria-label="theme switch" id=theme-toggle><span class=moon-icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></span> <span class=sun-icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill=currentColor></path></svg></span></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><dialog id=rss-mask><div><a href=https://donkomura.github.io/blog/feed.xml>https://donkomura.github.io/blog/feed.xml</a><button data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' aria-label=copy autofocus data-link=https://donkomura.github.io/blog/feed.xml><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill=currentColor></path></svg></button></div></dialog><div id=wrapper><div id=blank></div><aside><nav><ul><li><a class=h2 href=#naze-rust-defen-san-sisutemuwoshi-zhuang-surunoka>なぜ Rust で分散システムを実装するのか</a><li><a class=h2 href=#akitekutiyagai-yao>アーキテクチャ概要</a> <ul><li><a class=h3 href=#zhuang-tai-guan-li-xing-deshi-yang-wobiao-xian-suru>状態管理：型で仕様を表現する</a></ul><li><a class=h2 href=#toreitotoxing-sisutemuniyorushe-ji>トレイトと型システムによる設計</a> <ul><li><a class=h3 href=#1-statemachine-toreito-kuo-zhang-ke-neng-nazhuang-tai-ji-jie>1. StateMachine トレイト：拡張可能な状態機械</a><li><a class=h3 href=#2-storage-toreito-yong-sok-hua-ceng-nochou-xiang-hua>2. Storage トレイト：永続化層の抽象化</a><li><a class=h3 href=#3-raftrpc-toreito-xing-an-quan-na-rpc-ding-yi>3. RaftRpc トレイト：型安全な RPC 定義</a><li><a class=h3 href=#4-gong-you-zhuang-tai-noan-quan-naguan-li>4. 共有状態の安全な管理</a></ul><li><a class=h2 href=#raft-arugorizumunoshi-zhuang>Raft アルゴリズムの実装</a> <ul><li><a class=h3 href=#leader-election-fei-tong-qi-bing-lie-chu-li>Leader Election：非同期並列処理</a><li><a class=h3 href=#log-replication-bing-lie-shi-xing>Log Replication：並列実行</a></ul><li><a class=h2 href=#jin-hou-nozhan-wang>今後の展望</a><li><a class=h2 href=#matome>まとめ</a><li><a class=h2 href=#can-kao-wen-xian>参考文献</a></ul></nav><button aria-label="back to top" id=back-to-top><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill=currentColor></path></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1>RustでRaft Consensus Algorithmを実装した</h1><div id=post-info><div id=date><span id=publish>2025-12-24</span></div><div id=tags><a class=instant href=https://donkomura.github.io/tags/rust><span>#</span>rust</a><a class=instant href=https://donkomura.github.io/tags/distributed-systems><span>#</span>distributed-systems</a><a class=instant href=https://donkomura.github.io/tags/raft><span>#</span>raft</a><a class=instant href=https://donkomura.github.io/tags/consensus><span>#</span>consensus</a></div></div><p>分散システムにおける合意形成アルゴリズムとして知られている Raft を、Rust で実装してみた。この記事では、Rust の型システムとトレイトを活用した設計について紹介する。</p><span id=continue-reading></span><h2 id=naze-rust-defen-san-sisutemuwoshi-zhuang-surunoka>なぜ Rust で分散システムを実装するのか<a aria-label="Anchor link for: naze-rust-defen-san-sisutemuwoshi-zhuang-surunoka" class=zola-anchor href=#naze-rust-defen-san-sisutemuwoshi-zhuang-surunoka style=visibility:hidden></a></h2><p>分散システムの実装では、データ競合や状態不整合が実行時エラーを引き起こす可能性がある。また、拡張性を確保しつつ実装の誤りを防ぐ必要があり、複数ノード間の通信でスレッド安全性を保証する必要もある。<p>これらの課題に対して、Rust の型システムとトレイトを使うことで、抽象インターフェースを定義し実装の誤りをコンパイル時に検出できる。さらに、所有権システムによりデータ競合をコンパイル時に防げるため、並行処理の安全性を保証しやすい。<p>この記事では、<a rel="nofollow noreferrer" href=https://github.com/donkomura/ikada>ikada</a> という、<a rel="nofollow noreferrer" href=https://raft.github.io/raft.pdf>Raft の論文</a>のコア機能を実装したライブラリを例に、型システムとトレイトをどう活用したかを紹介する。<p>実装した主な機能：<ul><li>Leader Election (リーダー選出)<li>Log Replication (ログレプリケーション)<li>Safety Guarantees (安全性の保証)<li>State Persistence (状態の永続化)<li>Client Interaction (クライアントとの通信)</ul><h2 id=akitekutiyagai-yao>アーキテクチャ概要<a aria-label="Anchor link for: akitekutiyagai-yao" class=zola-anchor href=#akitekutiyagai-yao style=visibility:hidden></a></h2><h3 id=zhuang-tai-guan-li-xing-deshi-yang-wobiao-xian-suru>状態管理：型で仕様を表現する<a aria-label="Anchor link for: zhuang-tai-guan-li-xing-deshi-yang-wobiao-xian-suru" class=zola-anchor href=#zhuang-tai-guan-li-xing-deshi-yang-wobiao-xian-suru style=visibility:hidden></a></h3><p>Raft の論文 Figure 2 には、ノードが管理すべき状態が定義されている。これを <code>RaftState</code> 構造体で忠実に実装した：<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#f92672>pub </span><span style=color:#66d9ef;font-style:italic>struct </span><span>RaftState&lt;T: </span><span style=color:#66d9ef;font-style:italic>Send </span><span style=color:#f92672>+ </span><span style=color:#66d9ef;font-style:italic>Sync</span><span>, SM: StateMachine&lt;Command = T>> {
</span><span>    </span><span style=color:#75715e>// Persistent state on all servers（永続化が必要）
</span><span>    </span><span style=color:#f92672>pub </span><span>persistent: PersistentState&lt;T>,
</span><span>
</span><span>    </span><span style=color:#75715e>// Volatile state on all servers（揮発性）
</span><span>    </span><span style=color:#f92672>pub </span><span>commit_index: </span><span style=color:#66d9ef;font-style:italic>u32</span><span>,
</span><span>    </span><span style=color:#f92672>pub </span><span>last_applied: </span><span style=color:#66d9ef;font-style:italic>u32</span><span>,
</span><span>
</span><span>    </span><span style=color:#75715e>// Volatile state on leader（Leaderのみ）
</span><span>    </span><span style=color:#f92672>pub </span><span>next_index: HashMap&lt;SocketAddr, </span><span style=color:#66d9ef;font-style:italic>u32</span><span>>,
</span><span>    </span><span style=color:#f92672>pub </span><span>match_index: HashMap&lt;SocketAddr, </span><span style=color:#66d9ef;font-style:italic>u32</span><span>>,
</span><span>
</span><span>    </span><span style=color:#f92672>pub </span><span>role: Role,
</span><span>    storage: </span><span style=color:#66d9ef;font-style:italic>Box</span><span>&lt;dyn Storage&lt;T>>,  </span><span style=color:#75715e>// トレイトオブジェクトで抽象化
</span><span>    sm: SM,                        </span><span style=color:#75715e>// ジェネリクスで型安全性
</span><span>}
</span></code></pre><p>永続化が必要な状態を <code>PersistentState</code> 構造体として物理的に分離している。これにより、再起動時に復旧すべき状態が型として明確になる。また、型パラメータ <code>T: Send + Sync</code> でコマンド型を抽象化し、<code>SM: StateMachine&lt;Command = T></code> でステートマシンを差し替え可能にしている。<p>ノードのロールは Enum で表現している：<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span>#[derive(Debug, Clone, Copy, Default, PartialEq)]
</span><span style=color:#f92672>pub </span><span style=color:#66d9ef;font-style:italic>enum </span><span>Role {
</span><span>    #[default]
</span><span>    Follower,
</span><span>    Candidate,
</span><span>    Leader,
</span><span>}
</span></code></pre><p>Enum によって、ノードのロールが常に3つのうちいずれか1つであることが保証される。<h2 id=toreitotoxing-sisutemuniyorushe-ji>トレイトと型システムによる設計<a aria-label="Anchor link for: toreitotoxing-sisutemuniyorushe-ji" class=zola-anchor href=#toreitotoxing-sisutemuniyorushe-ji style=visibility:hidden></a></h2><p>Rust の型システムを活用した設計について説明する。<h3 id=1-statemachine-toreito-kuo-zhang-ke-neng-nazhuang-tai-ji-jie>1. StateMachine トレイト：拡張可能な状態機械<a aria-label="Anchor link for: 1-statemachine-toreito-kuo-zhang-ke-neng-nazhuang-tai-ji-jie" class=zola-anchor href=#1-statemachine-toreito-kuo-zhang-ke-neng-nazhuang-tai-ji-jie style=visibility:hidden></a></h3><p>Raft は合意形成のコアアルゴリズムで、実際にどんな状態機械（State Machine）を動かすかはユーザー次第である。<code>StateMachine</code> トレイトを定義することで、任意の状態機械を統合できるようにしている：<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span>#[async_trait::async_trait]
</span><span style=color:#f92672>pub </span><span style=color:#66d9ef;font-style:italic>trait </span><span>StateMachine: Send + Sync {
</span><span>    </span><span style=color:#66d9ef;font-style:italic>type </span><span>Command: </span><span style=color:#66d9ef;font-style:italic>Send </span><span style=color:#f92672>+ </span><span style=color:#66d9ef;font-style:italic>Sync </span><span style=color:#f92672>+ </span><span style=color:#66d9ef;font-style:italic>Clone</span><span>;
</span><span>    </span><span style=color:#66d9ef;font-style:italic>type </span><span>Response: </span><span style=color:#66d9ef;font-style:italic>Send </span><span style=color:#f92672>+ </span><span style=color:#66d9ef;font-style:italic>Sync</span><span>;
</span><span>
</span><span>    async </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>apply</span><span>(
</span><span>        </span><span style=color:#f92672>&mut </span><span style=color:#fd971f;font-style:italic>self</span><span>,
</span><span>        </span><span style=color:#fd971f;font-style:italic>command</span><span>: </span><span style=color:#f92672>&</span><span style=color:#66d9ef;font-style:italic>Self::</span><span>Command,
</span><span>    ) -> anyhow::</span><span style=color:#66d9ef;font-style:italic>Result</span><span>&lt;</span><span style=color:#66d9ef;font-style:italic>Self::</span><span>Response>;
</span><span>}
</span></code></pre><p>インターフェースはシンプルにしている。<code>apply</code> メソッド1つだけを定義し、コマンドを受け取って結果を返す形にした。<code>Command</code> と <code>Response</code> を関連型にすることで、ユーザーが任意の型を指定できる。したがって、Key-Value Store、データベース、計算エンジンなど、様々な状態機械に対応できる。<p>また、<code>Send + Sync</code> 制約により、コンパイラが自動的にスレッド安全性をチェックする。これにより、マルチスレッド環境で非スレッド安全な型を使った場合、コンパイル時にエラーとなる。<p>デフォルト実装として Key-Value Store を提供している：<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#75715e>// デフォルトのKVストア実装
</span><span>#[derive(Default, Debug)]
</span><span style=color:#f92672>pub </span><span style=color:#66d9ef;font-style:italic>struct </span><span>KVStateMachine {
</span><span>    data: HashMap&lt;</span><span style=color:#66d9ef;font-style:italic>String</span><span>, </span><span style=color:#66d9ef;font-style:italic>String</span><span>>,
</span><span>}
</span><span>
</span><span>#[derive(Clone, Debug, Serialize, Deserialize)]
</span><span style=color:#f92672>pub </span><span style=color:#66d9ef;font-style:italic>enum </span><span>KVCommand {
</span><span>    Set { key: </span><span style=color:#66d9ef;font-style:italic>String</span><span>, value: </span><span style=color:#66d9ef;font-style:italic>String </span><span>},
</span><span>    Get { key: </span><span style=color:#66d9ef;font-style:italic>String </span><span>},
</span><span>    Delete { key: </span><span style=color:#66d9ef;font-style:italic>String </span><span>},
</span><span>}
</span></code></pre><h3 id=2-storage-toreito-yong-sok-hua-ceng-nochou-xiang-hua>2. Storage トレイト：永続化層の抽象化<a aria-label="Anchor link for: 2-storage-toreito-yong-sok-hua-ceng-nochou-xiang-hua" class=zola-anchor href=#2-storage-toreito-yong-sok-hua-ceng-nochou-xiang-hua style=visibility:hidden></a></h3><p>Raft の状態を永続化するため、<code>Storage</code> トレイトを定義している：<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span>#[async_trait::async_trait]
</span><span style=color:#f92672>pub </span><span style=color:#66d9ef;font-style:italic>trait </span><span>Storage&lt;T: Send + Sync>: Send + Sync {
</span><span>    async </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>save</span><span>(</span><span style=color:#f92672>&mut </span><span style=color:#fd971f;font-style:italic>self</span><span>, </span><span style=color:#fd971f;font-style:italic>state</span><span>: </span><span style=color:#f92672>&</span><span>PersistentState&lt;T>) -> anyhow::</span><span style=color:#66d9ef;font-style:italic>Result</span><span>&lt;()>;
</span><span>    async </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>load</span><span>(</span><span style=color:#f92672>&</span><span style=color:#fd971f;font-style:italic>self</span><span>) -> anyhow::</span><span style=color:#66d9ef;font-style:italic>Result</span><span>&lt;</span><span style=color:#66d9ef;font-style:italic>Option</span><span>&lt;PersistentState&lt;T>>>;
</span><span>}
</span></code></pre><p>このトレイトにより、バックエンドの切り替えが容易になる。したがって、メモリ、ファイルシステム、データベースなど、実装を差し替えるだけで対応できる。例えば、テストではメモリストレージを使い、本番環境では永続化ストレージを使うといった使い分けができる。<h3 id=3-raftrpc-toreito-xing-an-quan-na-rpc-ding-yi>3. RaftRpc トレイト：型安全な RPC 定義<a aria-label="Anchor link for: 3-raftrpc-toreito-xing-an-quan-na-rpc-ding-yi" class=zola-anchor href=#3-raftrpc-toreito-xing-an-quan-na-rpc-ding-yi style=visibility:hidden></a></h3><p>ノード間通信には <a rel="nofollow noreferrer" href=https://github.com/google/tarpc>tarpc</a> を使用し、RPC インターフェースをトレイトで定義している：<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span>#[tarpc::service]
</span><span style=color:#f92672>pub </span><span style=color:#66d9ef;font-style:italic>trait </span><span>RaftRpc {
</span><span>    async </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>append_entries</span><span>(</span><span style=color:#fd971f;font-style:italic>req</span><span>: AppendEntriesRequest) -> AppendEntriesResponse;
</span><span>    async </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>request_vote</span><span>(</span><span style=color:#fd971f;font-style:italic>req</span><span>: RequestVoteRequest) -> RequestVoteResponse;
</span><span>    async </span><span style=color:#66d9ef;font-style:italic>fn </span><span style=color:#a6e22e>client_request</span><span>(</span><span style=color:#fd971f;font-style:italic>req</span><span>: CommandRequest) -> CommandResponse;
</span><span>}
</span></code></pre><p>リクエスト/レスポンスの型が一致しない場合、コンパイル時にエラーとなる。また、tarpc が自動的にクライアント/サーバーコードを生成するため、ボイラープレートを書く必要がない。<h3 id=4-gong-you-zhuang-tai-noan-quan-naguan-li>4. 共有状態の安全な管理<a aria-label="Anchor link for: 4-gong-you-zhuang-tai-noan-quan-naguan-li" class=zola-anchor href=#4-gong-you-zhuang-tai-noan-quan-naguan-li style=visibility:hidden></a></h3><p>分散システムでは状態の共有が不可欠だが、Rust の所有権システムと調和させる必要がある。そこで、<code>Arc&lt;Mutex&lt;RaftState>></code> を使用することで、安全な共有可変状態を実現している：<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#f92672>pub </span><span style=color:#66d9ef;font-style:italic>struct </span><span>Node&lt;T: </span><span style=color:#66d9ef;font-style:italic>Send </span><span style=color:#f92672>+ </span><span style=color:#66d9ef;font-style:italic>Sync</span><span>, SM: StateMachine&lt;Command = T>> {
</span><span>    state: Arc&lt;Mutex&lt;RaftState&lt;T, SM>>>,
</span><span>    </span><span style=color:#75715e>// ...
</span><span>}
</span></code></pre><p><code>Mutex</code> により、同時に1つのスレッドしか状態を変更できないため、データ競合を防げる。<code>Arc</code> により、どのスレッドが状態を共有しているか追跡でき、参照カウントが0になると自動的にメモリが解放される。<p>ただし、Rust の型システムは「Mutex 保護領域を触るにはロックが必要」という制約を保証できるが、デッドロックや非同期コンテキストでの <code>.await</code> をまたいだロック保持、タスク飢餓などは別途設計で対処する必要がある。これらの課題については「今後の展望」セクションで触れる。<p>なお、各種通知に関してはチャネルで実装した。Go と似たメンタルモデルで実装できたのは、Go の経験が生きたように感じた。<h2 id=raft-arugorizumunoshi-zhuang>Raft アルゴリズムの実装<a aria-label="Anchor link for: raft-arugorizumunoshi-zhuang" class=zola-anchor href=#raft-arugorizumunoshi-zhuang style=visibility:hidden></a></h2><p>Rust の型システムを活用した設計について説明してきたが、次に Raft の具体的なアルゴリズム実装について触れる。<h3 id=leader-election-fei-tong-qi-bing-lie-chu-li>Leader Election：非同期並列処理<a aria-label="Anchor link for: leader-election-fei-tong-qi-bing-lie-chu-li" class=zola-anchor href=#leader-election-fei-tong-qi-bing-lie-chu-li style=visibility:hidden></a></h3><p>Follower は一定時間 Leader からのハートビートを受信しないと、Candidate に遷移して選挙を開始する。すべてのピアに並列で RequestVote RPC を送信する。<pre class=language-rust data-lang=rust style=color:#f8f8f2;background-color:#272822><code class=language-rust data-lang=rust><span style=color:#75715e>// Request votes from all peers in parallel
</span><span style=color:#66d9ef;font-style:italic>let </span><span style=color:#f92672>mut</span><span> tasks </span><span style=color:#f92672>= </span><span>JoinSet::new();
</span><span style=color:#f92672>for </span><span>(addr, client) </span><span style=color:#f92672>in</span><span> peers {
</span><span>    tasks.</span><span style=color:#66d9ef>spawn</span><span>(</span><span style=color:#66d9ef;font-style:italic>Self</span><span>::send_request_vote(addr, client, req, rpc_timeout));
</span><span>}
</span><span>
</span><span style=color:#75715e>// Collect responses
</span><span style=color:#f92672>while </span><span style=color:#66d9ef;font-style:italic>let Some</span><span>(result) </span><span style=color:#f92672>=</span><span> tasks.</span><span style=color:#66d9ef>join_next</span><span>().await {
</span><span>    </span><span style=color:#75715e>// レスポンスを収集
</span><span>}
</span></code></pre><p><code>tokio::task::JoinSet</code> を使用することで、複数の RPC を並列実行している。過半数の投票を獲得すると Leader に遷移する。<h3 id=log-replication-bing-lie-shi-xing>Log Replication：並列実行<a aria-label="Anchor link for: log-replication-bing-lie-shi-xing" class=zola-anchor href=#log-replication-bing-lie-shi-xing style=visibility:hidden></a></h3><p>Leader は AppendEntries RPC を使って Follower にログエントリを複製する。Log Replication も並列実行している。各 Follower の <code>next_index</code> に基づいて送信すべきエントリを決定し、並列で AppendEntries RPC を送信する。<h2 id=jin-hou-nozhan-wang>今後の展望<a aria-label="Anchor link for: jin-hou-nozhan-wang" class=zola-anchor href=#jin-hou-nozhan-wang style=visibility:hidden></a></h2><p>現在の実装は Raft のコア機能に焦点を当てているが、実用化に向けていくつかの機能を追加していく予定である。<p>まず、Cluster Membership Changes（論文§6）と Log Compaction and Snapshots（論文§7）の実装である。これらにより、クラスタの動的な構成変更とストレージ使用量の削減が可能になる。<p>また、AppendEntries 失敗時の <code>nextIndex</code> 調整については、論文に記載されている最適化（conflict term と conflict index）を実装することで、ログの整合性を効率的に取ることができる。単純に <code>nextIndex -= 1</code> とすると最悪 O(n²) の時間がかかるため、この最適化は重要である。<p>統合テストについては、ネットワークパーティションやクロックスキュー、メッセージの重複・遅延など、実際の分散環境で発生する障害シナリオのテストを充実させていく予定である。<p>最後に、パフォーマンス測定と最適化を行う予定である。現時点では機能の正確性を優先しているが、実用化にはスループットとレイテンシーの改善が必要になると思う。<h2 id=matome>まとめ<a aria-label="Anchor link for: matome" class=zola-anchor href=#matome style=visibility:hidden></a></h2><p>Rust で Raft を実装してみた。型システムとトレイトを活用することで、安全かつ拡張可能な設計ができたと感じている。<p>トレイトによる抽象化は有用だった。<code>StateMachine</code>、<code>Storage</code>、<code>RaftRpc</code> など、インターフェースを明確に定義することで、ユーザーが独自実装を差し込める拡張性を確保できた。また、型システムによる安全性も重要で、<code>Send + Sync</code> 境界やジェネリクスにより、コンパイル時にスレッド安全性や型の整合性をチェックできる。さらに、所有権システムは、<code>Arc&lt;Mutex&lt;T>></code> によるデータ競合の防止と、明確な所有権管理を実現する。<p>一方で、型システムだけでは防げない複雑な安全性ルールも存在する。例えば、現在の term のエントリのみコミットするという Raft の安全性ルールは、ロジックとして実装する必要がある。したがって、これらは明確な構造体設計と単体テストで補完している。<p>分散システムの実装は難しいが、Rust の型システムを活用することで、実行時エラーをコンパイル時に検出できる。これにより、安全性と開発効率の両立がしやすいと思う。<p>興味のある方は、<a rel="nofollow noreferrer" href=https://github.com/donkomura/ikada>GitHub リポジトリ</a>をご覧いただきたい。<h2 id=can-kao-wen-xian>参考文献<a aria-label="Anchor link for: can-kao-wen-xian" class=zola-anchor href=#can-kao-wen-xian style=visibility:hidden></a></h2><ul><li><a rel="nofollow noreferrer" href=https://raft.github.io/raft.pdf>In Search of an Understandable Consensus Algorithm (Extended Version)</a><li><a rel="nofollow noreferrer" href=http://thesecretlivesofdata.com/raft/>Raft Visualization</a><li><a rel="nofollow noreferrer" href=https://raft.github.io/>Raft GitHub Pages</a></ul></article></div><footer><div class=copyright><p>© 2025 donko</div><div class=credits>powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>serene</a></div></footer></main></div><script src=/js/lightense.min.js></script><script src=/js/main.js></script>